package generic

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/bytedance/sonic"
	"github.com/rezatg/gitc/internal/ai"
	"github.com/rezatg/gitc/pkg/utils"
	"github.com/valyala/fasthttp"
	"github.com/valyala/fasthttp/fasthttpproxy"
)

// Default URLs for supported providers
const (
	defaultOpenAIURL   = "https://api.openai.com/v1/chat/completions"
	defaultGrokURL     = "https://api.x.ai/v1/chat/completions"
	defaultDeepSeekURL = "https://api.deepseek.com/v1/chat/completions"
	systemPrompt       = "You are an AI assistant that generates concise and meaningful Git commit messages."
)

// GenericProvider implements the AIProvider interface for OpenAI-compatible APIs
type GenericProvider struct {
	apiKey   string
	client   *fasthttp.Client
	url      string
	provider string
}

// NewGenericProvider creates a new provider for OpenAI-compatible APIs
func NewGenericProvider(apiKey, proxy, url, provider string) (*GenericProvider, error) {
	if apiKey == "" {
		return nil, errors.New("API key is required")
	}
	if url == "" {
		switch provider {
		case "openai":
			url = defaultOpenAIURL
		case "grok":
			url = defaultGrokURL
		case "deepseek":
			url = defaultDeepSeekURL
		default:
			return nil, fmt.Errorf("no default URL for provider: %s", provider)
		}
	}

	client := &fasthttp.Client{
		MaxConnsPerHost: 10,
	}

	if proxy != "" {
		client.Dial = fasthttpproxy.FasthttpHTTPDialer(proxy)
	}

	return &GenericProvider{
		apiKey:   apiKey,
		client:   client,
		url:      url,
		provider: provider,
	}, nil
}

type Request struct {
	Model       string    `json:"model"`
	Messages    []Message `json:"messages"`
	MaxTokens   int       `json:"max_tokens,omitempty"`
	Temperature float32   `json:"temperature,omitempty"`
}

type Response struct {
	Choices []struct {
		Message Message `json:"message"`
	} `json:"choices"`
	Error struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// GenerateCommitMessage generates a commit message using the API
func (p *GenericProvider) GenerateCommitMessage(ctx context.Context, diff string, opts ai.MessageOptions) (string, error) {
	// Adjust prompt based on provider if needed
	prompt := utils.GetPromptForSingleCommit(diff, opts.CommitType, opts.CustomConvention, opts.Language)

	reqBody := Request{
		Model: opts.Model,
		// Store: false,
		Messages: []Message{
			{"system", systemPrompt},
			{"user", prompt},
		},
		MaxTokens:   max(512, opts.MaxLength), // More tokens for complete messages
		Temperature: 0.7,                      // Slightly creative but controlled
	}

	jsonData, err := sonic.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("failed to encode JSON: %v", err)
	}

	req := fasthttp.AcquireRequest()
	defer fasthttp.ReleaseRequest(req)

	req.SetRequestURI(p.url)
	req.Header.SetMethod("POST")
	req.Header.Set("Authorization", "Bearer "+p.apiKey)
	req.Header.Set("Content-Type", "application/json")
	req.SetBody(jsonData)

	resp := fasthttp.AcquireResponse()
	defer fasthttp.ReleaseResponse(resp)

	if err = p.client.DoRedirects(req, resp, opts.MaxRedirects); err != nil {
		return "", fmt.Errorf("API request failed: %w", err)
	}

	var res Response
	if err = sonic.Unmarshal(resp.Body(), &res); err != nil {
		return "", fmt.Errorf("failed to parse response: %v", err)
	}

	if statusCode := resp.StatusCode(); statusCode != fasthttp.StatusOK {
		if res.Error.Message != "" {
			return "", fmt.Errorf("API error [%d] from %s: %s", statusCode, p.provider, res.Error.Message)
		}

		return "", fmt.Errorf("API returned status %d from %s: %s", statusCode, p.provider, resp.Body())
	}

	if res.Error.Message != "" {
		return "", fmt.Errorf("API error from %s: %s", p.provider, res.Error.Message)
	} else if len(res.Choices) == 0 {
		return "", fmt.Errorf("no response from %s", p.provider)
	}

	commitMessage := strings.TrimSpace(res.Choices[0].Message.Content)
	if commitMessage == "" {
		return "", fmt.Errorf("empty commit message generated by %s", p.provider)
	}

	return commitMessage, nil
}
